package example.com.app.daos;

import example.com.app.models.Card;
import example.com.app.models.Deck;

import example.com.app.models.User;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
//needed to get access to the SERIAL (autoincrement) cardID field after INSERT INTO Statement (is needed to return autogenerated keys)
import java.sql.Statement;


public class CardDAO {

    @Setter(AccessLevel.PRIVATE)
    @Getter(AccessLevel.PRIVATE)
    Connection connection;


    @Setter(AccessLevel.PRIVATE)
    ArrayList <Card> cardsCache;


    public CardDAO(Connection connection) {
        setConnection(connection);
    }


    //gets all cards from a user that has a specific token
    public ArrayList <Card> getAllCards(String token) {
        ArrayList <Card> cards =new ArrayList();
        String selectStmt = "SELECT c.CardID, c.CardName, c.Damage FROM Cards c " +
                "JOIN Stacks s ON c.CardID = s.CardID " +
                "JOIN Users u ON s.UserID = u.UserID " +
                "WHERE u.Token = ?";

        try {
            PreparedStatement preparedStatement = getConnection().prepareStatement(selectStmt);
            preparedStatement.setString(1, token);

            ResultSet resultSet = preparedStatement.executeQuery();

            while(resultSet.next()) {
                Card card = new Card(resultSet.getString(1), resultSet.getString(2), resultSet.getInt(3));
                cards.add(card);
            }
            //getConnection().close();
            return cards;
        }


        catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    //gets the deck from a user that has a specific token
    public ArrayList <String> getDeck(String token) {
        ArrayList <String> deck =new ArrayList();

        String selectStmt = "SELECT D.DeckID, D.Card1, D.Card2, D.Card3, D.Card4 " +
                "FROM Decks D " +
                "JOIN Users U ON D.DeckID = U.DeckID " +
                "WHERE U.Token = ?";

        try {
            PreparedStatement preparedStatement = getConnection().prepareStatement(selectStmt);
            preparedStatement.setString(1, token);
            ResultSet resultSet = preparedStatement.executeQuery();

            //for(int i = 0; i < 4; i++ ) {
            while(resultSet.next()) {
                for(int i = 2; i < 6; i++) {
                    deck.add(resultSet.getString(i));
                    System.out.println("this is the card: "+ resultSet.getString(i));
                }
            }
            //getConnection().close();
            return deck;
        }
        catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    //get a single card based on cardID
    public Card getSingleCard(String cardID) {
        String selectStmt = "SELECT CardName, Damage" +
                " FROM Cards" +
                " WHERE cardID = ?";

        try {
            PreparedStatement preparedStatement = getConnection().prepareStatement(selectStmt);
            preparedStatement.setString(1, cardID);
            ResultSet resultSet = preparedStatement.executeQuery();


            if (resultSet.next()) {
                //move the cursor to the first row of the result set
                Card card = new Card(cardID, resultSet.getString("CardName"), resultSet.getInt("Damage"));
                return card;
            } else {
                //no rows found for the given cardID
                return null;
            }
            //Card card = new Card(cardID, resultSet.getString(1), resultSet.getInt(2));
            //todo fix close
            //getConnection().close();
            //return card;
        }
        catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void updateDeck(Deck newDeck, String token) {
        System.out.println("updateDeck was called");
        try {
            getConnection().setAutoCommit(false);
            //check if the user has a deck (a deckID exists in userstable for the user with this token)
            String selectStmt = "SELECT deckID" +
                    " FROM Users" +
                    " WHERE token = ?";
            try (PreparedStatement preparedStatement = getConnection().prepareStatement(selectStmt)) {
                preparedStatement.setString(1, token);
                ResultSet resultSet = preparedStatement.executeQuery();

                int deckIDfromUserDeck = 0;
                if (resultSet.next()) {
                    deckIDfromUserDeck = resultSet.getInt("deckID");
                }
                //if the user has a deck (deckID is set in user table) then update the users deck with newDeck)
                if (deckIDfromUserDeck != 0) {
                    System.out.println("the user seems to have a deck with deckID: "+ deckIDfromUserDeck);
                    preparedStatement.execute();
                    String updateStmt ="UPDATE Decks SET card1 = ?, card2 = ?, card3 = ?, card4 = ? WHERE deckID = ?";
                    PreparedStatement preparedStatement2 = getConnection().prepareStatement(updateStmt);
                    preparedStatement2.setString(1, newDeck.getCard1());
                    preparedStatement2.setString(2, newDeck.getCard2());
                    preparedStatement2.setString(3, newDeck.getCard3());
                    preparedStatement2.setString(4, newDeck.getCard4());
                    preparedStatement2.setInt(5, deckIDfromUserDeck);
                    preparedStatement2.executeUpdate();

                //if no deck for the user exists yet. create new deck in decks table and write deckID in user table(column deckID)
                } else {
                    System.out.println("the user doesnt have a deck");
                    String insertStmt = "INSERT INTO Decks (card1, card2, card3, card4) VALUES (?, ?, ?, ?)";

                    // Statement.RETURN_GENERATED_KEYS is needed to return autogenerated keys
                    try (PreparedStatement insertPreparedStatement = getConnection().prepareStatement(insertStmt, Statement.RETURN_GENERATED_KEYS)) {
                        insertPreparedStatement.setString(1, newDeck.getCard1());
                        insertPreparedStatement.setString(2, newDeck.getCard2());
                        insertPreparedStatement.setString(3, newDeck.getCard3());
                        insertPreparedStatement.setString(4, newDeck.getCard4());

                        int affectedRows = insertPreparedStatement.executeUpdate();
                        //get the generated deckID of the new entry and update the users tables deckID field with it
                        if (affectedRows > 0) {
                            ResultSet generatedKeys = insertPreparedStatement.getGeneratedKeys();
                            if (generatedKeys.next()) {
                                int newDeckID = generatedKeys.getInt(1);
                                System.out.println("new deck id: " +newDeckID);
                                String updateStmt ="UPDATE Users SET deckID = ? WHERE token = ?";
                                PreparedStatement preparedStatement3 = getConnection().prepareStatement(updateStmt);
                                preparedStatement3.setInt(1, newDeckID);
                                preparedStatement3.setString(2, token);
                                preparedStatement3.executeUpdate();
                            }
                        }
                    }
                }
                //getConnection().close();
            }
            getConnection().commit();

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    //checks if user owns the card  -> user can only have cards that are exist in the db (card table)
    public Boolean checkIfCardsExist(String[] cardIDs, String token) {
        try {
            getConnection().setAutoCommit(false);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }

        //check if user owns one of the cards
        String selectStmt = "SELECT c.CardID FROM Cards c " +
                "JOIN Stacks s ON c.CardID = s.CardID " +
                "JOIN Users u ON s.UserID = u.UserID " +
                "WHERE u.Token = ?";

        try {
            PreparedStatement preparedStatement = getConnection().prepareStatement(selectStmt);
            preparedStatement.setString(1, token);
            ResultSet resultSet = preparedStatement.executeQuery();

            ArrayList<String> userCardIDs = new ArrayList<>();
            while(resultSet.next()) {
                userCardIDs.add(resultSet.getString(1));
            }

            //iterates through the cardIDs(from the deck and compares it with the userCardIDs (all cards owned by user)
            //if a card is not found, false is returned
            for (String cardID : cardIDs) {
                boolean found = false;
                for (String userCardID : userCardIDs) {
                    if (userCardID.equals(cardID)) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    return false;
                }
            }

            getConnection().commit();
            return true;

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}